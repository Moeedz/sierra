<!doctype html>

<html lang="{{ request.locale.iso_code }}" dir="{% render 'direction' %}">
  <head>
    {% if template == 'password' %}
     <style>
      .essential_free_shipping_bar_wrapper.free_shipping_bar_wrapper_cmfaqkmaw00fwvg2ufmy9adv3 {
    display: none !important;
}
     </style>
    {% endif %}
<style>
  .spiral {
    color: #B6F7FF !important;
    font-size: 1.25em !important;
    padding-right: 5px;
  }
</style>

<script>
(function() {
  // Track processed nodes to avoid duplicates
  const processedNodes = new WeakSet();
  
  function replaceAllSpirals() {
    // Find ALL text nodes
    const walker = document.createTreeWalker(
      document.body,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node) {
          // Skip if already processed
          if (processedNodes.has(node)) {
            return NodeFilter.FILTER_REJECT;
          }
          
          // Skip script and style tags
          const parent = node.parentElement;
          if (!parent || parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {
            return NodeFilter.FILTER_REJECT;
          }
          
          // Skip if parent already has .spiral class
          if (parent.classList && parent.classList.contains('spiral')) {
            return NodeFilter.FILTER_REJECT;
          }
          
          // Accept nodes that CONTAIN the spiral (not just equal to it)
          if (node.nodeValue && node.nodeValue.includes('꩜')) {
            return NodeFilter.FILTER_ACCEPT;
          }
          
          return NodeFilter.FILTER_REJECT;
        }
      }
    );

    const nodesToProcess = [];
    let node;
    
    // Collect all text nodes with spirals
    while (node = walker.nextNode()) {
      nodesToProcess.push(node);
    }

    console.log('Found ' + nodesToProcess.length + ' text nodes with spirals');

    // Replace spirals in each text node
    nodesToProcess.forEach(function(textNode) {
      if (textNode.nodeValue.includes('꩜') && !processedNodes.has(textNode)) {
        const text = textNode.nodeValue;
        const parts = text.split('꩜');
        
        // Create a document fragment to hold the new nodes
        const fragment = document.createDocumentFragment();
        
        parts.forEach(function(part, index) {
          // Add the text part (if not empty)
          if (part) {
            const textNode = document.createTextNode(part);
            fragment.appendChild(textNode);
            processedNodes.add(textNode);
          }
          
          // Add the styled spiral between parts (not after the last part)
          if (index < parts.length - 1) {
            const span = document.createElement('span');
            span.className = 'spiral';
            span.textContent = '꩜';
            fragment.appendChild(span);
            
            // Mark the span's text as processed
            if (span.firstChild) {
              processedNodes.add(span.firstChild);
            }
          }
        });
        
        // Mark original as processed
        processedNodes.add(textNode);
        
        // Replace the original text node with the fragment
        textNode.parentNode.replaceChild(fragment, textNode);
      }
    });
  }

  // Run when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', replaceAllSpirals);
  } else {
    replaceAllSpirals();
  }

  // Also run after a short delay (for Shopify sections)
  setTimeout(replaceAllSpirals, 500);

  // Watch for dynamically added content
  const observer = new MutationObserver(function(mutations) {
    let shouldReplace = false;
    
    mutations.forEach(function(mutation) {
      mutation.addedNodes.forEach(function(node) {
        if (node.nodeType === 1) { // Element node
          const text = node.textContent || '';
          if (text.includes('꩜') && !node.querySelector('.spiral')) {
            shouldReplace = true;
          }
        } else if (node.nodeType === 3) { // Text node
          if (node.nodeValue && node.nodeValue.includes('꩜') && !processedNodes.has(node)) {
            shouldReplace = true;
          }
        }
      });
    });
    
    if (shouldReplace) {
      setTimeout(replaceAllSpirals, 100);
    }
  });

  // Start observing after initial processing
  setTimeout(function() {
    if (document.body) {
      observer.observe(document.body, {
        childList: true,
        subtree: true,
        characterData: false
      });
    }
  }, 1000);

  // For drawers/modals/sidebars opening
  document.addEventListener('click', function(e) {
    const target = e.target.closest('[aria-controls], [data-drawer-toggle], button, a');
    if (target) {
      setTimeout(replaceAllSpirals, 300);
    }
  });

  // For Shopify theme editor
  if (typeof Shopify !== 'undefined' && Shopify.designMode) {
    document.addEventListener('shopify:section:load', replaceAllSpirals);
    document.addEventListener('shopify:section:reorder', replaceAllSpirals);
  }

})();
</script>
    <style>
.popover .h4, cart-drawer#cart-drawer .h4, .product-sticky-bar__info span, sold-out-badge {
    font-family: 'Poppins' !important;
}
span.currency-converter-amount-box * {
    font-size: 11px !important;
    color: #00000080 !important;
}
      section#shopify-section-template--25661479354677__slideshow_7dgTyP a.button:hover {
  color: black !important;
  border-color: black !important;
}
.header-sidebar__scroller li a, .header-sidebar__scroller li button {
    text-transform: uppercase !important;
}
button.localization-toggle.heading.text-xxs.link-faded span {
    font-family: 'Poppins' !important;
}
@media screen and (min-width: 768px) {
li.header__primary-nav-item a, li.header__primary-nav-item summary {
    font-size: 15px !important;
}
}
section#shopify-section-template--25661479354677__slideshow_7dgTyP a.button {
    padding: 12px 18px;
}
@media screen and (max-width: 767px) {
section#shopify-section-template--25661479354677__slideshow_7dgTyP .content-over-media.content-over-media--lg {
    height: 80vh !important;
}
}
.header-sidebar__linklist-button {
  font-size: 1.75rem !important;
  padding: 0.25rem !important;
}
.drawer::part(content) {
    background: #F1FCFD !important;
}
.header-sidebar__scroller {
    background: #F1FCFD !important;
}
.header-sidebar__nested-linklist {
    display: flex !important;
    flex-flow: column !important;
}
a.header-sidebar__linklist-button.header-sidebar__subcategory-heading.h6 {
    font-size: 15px !important;
}
.header-sidebar__linklist-button.header-sidebar__subcategory-heading.h6 {
    font-size: 15px !important;
}
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, height=device-height, minimum-scale=1.0, maximum-scale=5.0">

    <title>{% if page_title == blank %}{{ shop.name }}{% else %}{{ page_title }}{% if current_page != 1 %} &ndash; {{ 'general.page' | t: page: current_page }}{% endif %}{% endif %}</title>

    {%- if page_description -%}
      <meta name="description" content="{{ page_description | escape }}">
    {%- endif -%}

    <link rel="canonical" href="{{ canonical_url }}">

    {%- if settings.favicon -%}
      <link rel="shortcut icon" href="{{ settings.favicon | image_url: width: 96 }}">
      <link rel="apple-touch-icon" href="{{ settings.favicon | image_url: width: 180 }}">
    {%- endif -%}

    {%- comment -%}Few prefetch to increase performance on commonly used third-parties{%- endcomment -%}
    <link rel="preconnect" href="https://fonts.shopifycdn.com" crossorigin>

    {%- unless settings.heading_font.system? -%}
      <link rel="preload" href="{{ settings.heading_font | font_url }}" as="font" type="font/woff2" crossorigin>
    {%- endunless -%}

    {%- unless settings.text_font.system? -%}
      <link rel="preload" href="{{ settings.text_font | font_url }}" as="font" type="font/woff2" crossorigin>
    {%- endunless -%}

    {%- render 'social-meta-tags' -%}
    {%- render 'microdata-schema' -%}
    {%- render 'css-variables' -%}
    {%- render 'js-variables' -%}

    {%- if request.page_type == 'gift_card' -%}
      <script src="{{ 'vendor/qrcode.js' | shopify_asset_url }}" defer></script>
    {%- endif -%}

    <script>
      if (!(HTMLScriptElement.supports && HTMLScriptElement.supports('importmap'))) {
        const importMapPolyfill = document.createElement('script');
        importMapPolyfill.async = true;
        importMapPolyfill.src = "{{ 'es-module-shims.min.js' | asset_url }}";

        document.head.appendChild(importMapPolyfill);
      }
    </script>

    <script type="importmap">
      {%- comment -%}On Safari 16.3 and lower, a polyfill is used to load importmap{%- endcomment -%}
      {
        "imports": {
          "vendor": "{{ 'vendor.min.js' | asset_url }}",
          "theme": "{{ 'theme.js' | asset_url }}",
          "photoswipe": "{{ 'photoswipe.min.js' | asset_url }}"
        }
      }
    </script>

    <script type="module" src="{{ 'vendor.min.js' | asset_url }}"></script>
    <script type="module" src="{{ 'theme.js' | asset_url }}"></script>

    {{ content_for_header }}

    {{- 'theme.css' | asset_url | stylesheet_tag: preload: true -}}
  </head>

  {% liquid
    assign features_class = ''

    if settings.show_button_transition
      assign features_class = features_class | append: 'features--button-transition '
    endif

    if settings.show_image_zoom_on_hover
      assign features_class = features_class | append: 'features--zoom-image '
    endif

    if settings.show_page_transition
      assign features_class = features_class | append: 'features--page-transition '
    endif
  %}

  <body class="{{ features_class }} color-scheme color-scheme--{{ settings.default_color_scheme.id }}">
    {%- render 'shadow-dom-templates' -%}

    <loading-bar class="loading-bar" aria-hidden="true"></loading-bar>
    <a href="#main" allow-hash-change class="skip-to-content sr-only">{{ 'general.accessibility.skip_to_content' | t }}</a>

    <span id="header-scroll-tracker" style="position: absolute; width: 1px; height: 1px; top: var(--header-scroll-tracker-offset, 10px); left: 0;">
      {%- comment -%}
        This allows our theme to track when the user has scrolled a given amount of pixels, without relying on a global scroll listener. This helps
        to improve performance and reduce reflows.
      {%- endcomment -%}
    </span>

    {%- if request.page_type != 'password' -%}
      {%- sections 'header-group' -%}
      {%- sections 'overlay-group' -%}
    {%- endif -%}

    <main id="main" class="anchor">
      {{ content_for_layout }}

      {%- comment -%}
      IMPLEMENTATION NOTE: For best semantics, having the footer group outside the main would be slightly better, but
        moving it inside the main allows to have all the sections (including sections inside the footer group) to be
        consecutive, and hence having a cleaner margin collapsing management.
      {%- endcomment -%}
      {%- if request.page_type != 'password' -%}
        {%- sections 'footer-group' -%}
      {%- endif -%}
    </main>
  </body>
</html>
